// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sample.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		sample.proto

	It has these top-level messages:
		Action
		InfoSet
		Sample
*/
package model

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Card int32

const (
	Card_UNKNOWN              Card = 0
	Card_EXPLODING_KITTEN     Card = 1
	Card_DEFUSE               Card = 2
	Card_SKIP                 Card = 3
	Card_SLAP_1X              Card = 4
	Card_SLAP_2X              Card = 5
	Card_SEE_THE_FUTURE       Card = 6
	Card_SHUFFLE              Card = 7
	Card_DRAW_FROM_THE_BOTTOM Card = 8
	Card_CAT                  Card = 9
)

var Card_name = map[int32]string{
	0: "UNKNOWN",
	1: "EXPLODING_KITTEN",
	2: "DEFUSE",
	3: "SKIP",
	4: "SLAP_1X",
	5: "SLAP_2X",
	6: "SEE_THE_FUTURE",
	7: "SHUFFLE",
	8: "DRAW_FROM_THE_BOTTOM",
	9: "CAT",
}
var Card_value = map[string]int32{
	"UNKNOWN":              0,
	"EXPLODING_KITTEN":     1,
	"DEFUSE":               2,
	"SKIP":                 3,
	"SLAP_1X":              4,
	"SLAP_2X":              5,
	"SEE_THE_FUTURE":       6,
	"SHUFFLE":              7,
	"DRAW_FROM_THE_BOTTOM": 8,
	"CAT": 9,
}

func (x Card) String() string {
	return proto.EnumName(Card_name, int32(x))
}
func (Card) EnumDescriptor() ([]byte, []int) { return fileDescriptorSample, []int{0} }

type Action_Type int32

const (
	Action_INVALID              Action_Type = 0
	Action_DRAW_CARD            Action_Type = 1
	Action_PLAY_CARD            Action_Type = 2
	Action_GIVE_CARD            Action_Type = 3
	Action_INSERT_EXPLODING_CAT Action_Type = 4
)

var Action_Type_name = map[int32]string{
	0: "INVALID",
	1: "DRAW_CARD",
	2: "PLAY_CARD",
	3: "GIVE_CARD",
	4: "INSERT_EXPLODING_CAT",
}
var Action_Type_value = map[string]int32{
	"INVALID":              0,
	"DRAW_CARD":            1,
	"PLAY_CARD":            2,
	"GIVE_CARD":            3,
	"INSERT_EXPLODING_CAT": 4,
}

func (x Action_Type) String() string {
	return proto.EnumName(Action_Type_name, int32(x))
}
func (Action_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSample, []int{0, 0} }

type Action struct {
	Player             int32       `protobuf:"varint,1,opt,name=player,proto3" json:"player,omitempty"`
	Type               Action_Type `protobuf:"varint,2,opt,name=type,proto3,enum=model.Action_Type" json:"type,omitempty"`
	Card               Card        `protobuf:"varint,3,opt,name=card,proto3,enum=model.Card" json:"card,omitempty"`
	PositionInDrawPile int32       `protobuf:"varint,4,opt,name=position_in_draw_pile,json=positionInDrawPile,proto3" json:"position_in_draw_pile,omitempty"`
	CardsSeen          []Card      `protobuf:"varint,5,rep,packed,name=cards_seen,json=cardsSeen,enum=model.Card" json:"cards_seen,omitempty"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorSample, []int{0} }

func (m *Action) GetPlayer() int32 {
	if m != nil {
		return m.Player
	}
	return 0
}

func (m *Action) GetType() Action_Type {
	if m != nil {
		return m.Type
	}
	return Action_INVALID
}

func (m *Action) GetCard() Card {
	if m != nil {
		return m.Card
	}
	return Card_UNKNOWN
}

func (m *Action) GetPositionInDrawPile() int32 {
	if m != nil {
		return m.PositionInDrawPile
	}
	return 0
}

func (m *Action) GetCardsSeen() []Card {
	if m != nil {
		return m.CardsSeen
	}
	return nil
}

type InfoSet struct {
	History []*Action `protobuf:"bytes,1,rep,name=history" json:"history,omitempty"`
	Hand    []Card    `protobuf:"varint,2,rep,packed,name=hand,enum=model.Card" json:"hand,omitempty"`
}

func (m *InfoSet) Reset()                    { *m = InfoSet{} }
func (m *InfoSet) String() string            { return proto.CompactTextString(m) }
func (*InfoSet) ProtoMessage()               {}
func (*InfoSet) Descriptor() ([]byte, []int) { return fileDescriptorSample, []int{1} }

func (m *InfoSet) GetHistory() []*Action {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *InfoSet) GetHand() []Card {
	if m != nil {
		return m.Hand
	}
	return nil
}

type Sample struct {
	Iter       uint64    `protobuf:"varint,1,opt,name=iter,proto3" json:"iter,omitempty"`
	Infoset    *InfoSet  `protobuf:"bytes,2,opt,name=infoset" json:"infoset,omitempty"`
	Advantages []float32 `protobuf:"fixed32,3,rep,packed,name=advantages" json:"advantages,omitempty"`
}

func (m *Sample) Reset()                    { *m = Sample{} }
func (m *Sample) String() string            { return proto.CompactTextString(m) }
func (*Sample) ProtoMessage()               {}
func (*Sample) Descriptor() ([]byte, []int) { return fileDescriptorSample, []int{2} }

func (m *Sample) GetIter() uint64 {
	if m != nil {
		return m.Iter
	}
	return 0
}

func (m *Sample) GetInfoset() *InfoSet {
	if m != nil {
		return m.Infoset
	}
	return nil
}

func (m *Sample) GetAdvantages() []float32 {
	if m != nil {
		return m.Advantages
	}
	return nil
}

func init() {
	proto.RegisterType((*Action)(nil), "model.Action")
	proto.RegisterType((*InfoSet)(nil), "model.InfoSet")
	proto.RegisterType((*Sample)(nil), "model.Sample")
	proto.RegisterEnum("model.Card", Card_name, Card_value)
	proto.RegisterEnum("model.Action_Type", Action_Type_name, Action_Type_value)
}
func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.Player))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.Type))
	}
	if m.Card != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.Card))
	}
	if m.PositionInDrawPile != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.PositionInDrawPile))
	}
	if len(m.CardsSeen) > 0 {
		dAtA2 := make([]byte, len(m.CardsSeen)*10)
		var j1 int
		for _, num := range m.CardsSeen {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSample(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *InfoSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.History) > 0 {
		for _, msg := range m.History {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSample(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hand) > 0 {
		dAtA4 := make([]byte, len(m.Hand)*10)
		var j3 int
		for _, num := range m.Hand {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintSample(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Iter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.Iter))
	}
	if m.Infoset != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSample(dAtA, i, uint64(m.Infoset.Size()))
		n5, err := m.Infoset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Advantages) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSample(dAtA, i, uint64(len(m.Advantages)*4))
		for _, num := range m.Advantages {
			f6 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f6))
			i += 4
		}
	}
	return i, nil
}

func encodeVarintSample(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Action) Size() (n int) {
	var l int
	_ = l
	if m.Player != 0 {
		n += 1 + sovSample(uint64(m.Player))
	}
	if m.Type != 0 {
		n += 1 + sovSample(uint64(m.Type))
	}
	if m.Card != 0 {
		n += 1 + sovSample(uint64(m.Card))
	}
	if m.PositionInDrawPile != 0 {
		n += 1 + sovSample(uint64(m.PositionInDrawPile))
	}
	if len(m.CardsSeen) > 0 {
		l = 0
		for _, e := range m.CardsSeen {
			l += sovSample(uint64(e))
		}
		n += 1 + sovSample(uint64(l)) + l
	}
	return n
}

func (m *InfoSet) Size() (n int) {
	var l int
	_ = l
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovSample(uint64(l))
		}
	}
	if len(m.Hand) > 0 {
		l = 0
		for _, e := range m.Hand {
			l += sovSample(uint64(e))
		}
		n += 1 + sovSample(uint64(l)) + l
	}
	return n
}

func (m *Sample) Size() (n int) {
	var l int
	_ = l
	if m.Iter != 0 {
		n += 1 + sovSample(uint64(m.Iter))
	}
	if m.Infoset != nil {
		l = m.Infoset.Size()
		n += 1 + l + sovSample(uint64(l))
	}
	if len(m.Advantages) > 0 {
		n += 1 + sovSample(uint64(len(m.Advantages)*4)) + len(m.Advantages)*4
	}
	return n
}

func sovSample(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSample(x uint64) (n int) {
	return sovSample(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			m.Player = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Player |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Action_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			m.Card = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Card |= (Card(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionInDrawPile", wireType)
			}
			m.PositionInDrawPile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionInDrawPile |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v Card
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Card(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardsSeen = append(m.CardsSeen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Card
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Card(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardsSeen = append(m.CardsSeen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardsSeen", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &Action{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Card
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Card(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hand = append(m.Hand, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Card
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Card(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hand = append(m.Hand, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hand", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iter", wireType)
			}
			m.Iter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iter |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infoset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infoset == nil {
				m.Infoset = &InfoSet{}
			}
			if err := m.Infoset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Advantages = append(m.Advantages, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Advantages = append(m.Advantages, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Advantages", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSample(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSample
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSample
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSample
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSample(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSample = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSample   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sample.proto", fileDescriptorSample) }

var fileDescriptorSample = []byte{
	// 487 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x52, 0xcd, 0x6e, 0xda, 0x4c,
	0x14, 0x8d, 0x7f, 0xb0, 0xc3, 0x25, 0x41, 0xa3, 0xab, 0x7c, 0x9f, 0xbc, 0xa2, 0x88, 0x45, 0x8b,
	0xb2, 0x40, 0x0a, 0x7d, 0x02, 0x07, 0x0f, 0x89, 0x05, 0x31, 0x68, 0x6c, 0x12, 0xda, 0x8d, 0x35,
	0x8d, 0x87, 0xc6, 0x12, 0xb1, 0x2d, 0xdb, 0x6a, 0xc4, 0xc3, 0x74, 0xd7, 0x87, 0xe9, 0xb2, 0x8f,
	0x50, 0xf1, 0x24, 0xd5, 0x0c, 0xa6, 0xbf, 0xbb, 0x39, 0x73, 0xce, 0xb9, 0xf7, 0xce, 0xb9, 0x03,
	0x67, 0x15, 0x7f, 0x2e, 0xb6, 0x62, 0x54, 0x94, 0x79, 0x9d, 0x63, 0xeb, 0x39, 0x4f, 0xc4, 0x76,
	0xf0, 0x45, 0x07, 0xcb, 0x7d, 0xac, 0xd3, 0x3c, 0xc3, 0xff, 0xc1, 0x2a, 0xb6, 0x7c, 0x27, 0x4a,
	0x47, 0xeb, 0x6b, 0xc3, 0x16, 0x6b, 0x10, 0xbe, 0x06, 0xb3, 0xde, 0x15, 0xc2, 0xd1, 0xfb, 0xda,
	0xb0, 0x3b, 0xc6, 0x91, 0x32, 0x8e, 0x0e, 0xa6, 0x51, 0xb4, 0x2b, 0x04, 0x53, 0x3c, 0xbe, 0x02,
	0xf3, 0x91, 0x97, 0x89, 0x63, 0x28, 0x5d, 0xa7, 0xd1, 0x4d, 0x78, 0x99, 0x30, 0x45, 0xe0, 0x15,
	0xfc, 0x57, 0xe4, 0x55, 0x2a, 0x7d, 0x71, 0x9a, 0xc5, 0x49, 0xc9, 0x5f, 0xe2, 0x22, 0xdd, 0x0a,
	0xc7, 0x54, 0xfd, 0xf0, 0x48, 0xfa, 0x99, 0x57, 0xf2, 0x97, 0x65, 0xba, 0x15, 0x78, 0x09, 0x20,
	0xad, 0x55, 0x5c, 0x09, 0x91, 0x39, 0xad, 0xbe, 0xf1, 0x77, 0xe5, 0xb6, 0xa2, 0x43, 0x21, 0xb2,
	0xc1, 0x7b, 0x30, 0xe5, 0x34, 0xd8, 0x01, 0xdb, 0x0f, 0xee, 0xdd, 0xb9, 0xef, 0x91, 0x13, 0x3c,
	0x87, 0xb6, 0xc7, 0xdc, 0x87, 0x78, 0xe2, 0x32, 0x8f, 0x68, 0x12, 0x2e, 0xe7, 0xee, 0xbb, 0x03,
	0xd4, 0x25, 0xbc, 0xf1, 0xef, 0xe9, 0x01, 0x1a, 0xe8, 0xc0, 0x85, 0x1f, 0x84, 0x94, 0x45, 0x31,
	0x5d, 0x2f, 0xe7, 0x0b, 0xcf, 0x0f, 0x6e, 0xe2, 0x89, 0x1b, 0x11, 0x73, 0x10, 0x82, 0xed, 0x67,
	0x9b, 0x3c, 0x14, 0x35, 0xbe, 0x01, 0xfb, 0x29, 0xad, 0xea, 0xbc, 0xdc, 0x39, 0x5a, 0xdf, 0x18,
	0x76, 0xc6, 0xe7, 0x7f, 0x24, 0xc2, 0x8e, 0xac, 0xcc, 0xe3, 0x89, 0x67, 0x89, 0xa3, 0xff, 0x3b,
	0xb5, 0x22, 0x06, 0x1b, 0xb0, 0x42, 0xb5, 0x12, 0x44, 0x30, 0xd3, 0xba, 0x09, 0xde, 0x64, 0xea,
	0x8c, 0x43, 0xb0, 0xd3, 0x6c, 0x93, 0x57, 0xa2, 0x56, 0xc9, 0x77, 0xc6, 0xdd, 0xa6, 0x42, 0x33,
	0x08, 0x3b, 0xd2, 0xd8, 0x03, 0xe0, 0xc9, 0x27, 0x9e, 0xd5, 0xfc, 0xa3, 0xa8, 0x1c, 0xa3, 0x6f,
	0x0c, 0x75, 0xf6, 0xdb, 0xcd, 0xe5, 0x67, 0x0d, 0x4c, 0xd9, 0x56, 0x26, 0xb3, 0x0a, 0x66, 0xc1,
	0xe2, 0x21, 0x20, 0x27, 0x78, 0x01, 0xe4, 0xd7, 0x2b, 0x67, 0x7e, 0x14, 0xd1, 0x80, 0x68, 0x08,
	0x60, 0x79, 0x74, 0xba, 0x0a, 0x29, 0xd1, 0xf1, 0x14, 0xcc, 0x70, 0xe6, 0x2f, 0x89, 0x21, 0x8d,
	0xe1, 0xdc, 0x5d, 0xc6, 0x57, 0x6b, 0x62, 0xfe, 0x04, 0xe3, 0x35, 0x69, 0x21, 0x42, 0x37, 0xa4,
	0x34, 0x8e, 0x6e, 0x69, 0x3c, 0x5d, 0x45, 0x2b, 0x46, 0x89, 0xa5, 0x04, 0xb7, 0xab, 0xe9, 0x74,
	0x4e, 0x89, 0x2d, 0x33, 0x55, 0x0b, 0x98, 0xb2, 0xc5, 0x9d, 0x92, 0x5d, 0x2f, 0xa2, 0x68, 0x71,
	0x47, 0x4e, 0xd1, 0x06, 0x43, 0x86, 0xdb, 0xbe, 0x3e, 0xfb, 0xba, 0xef, 0x69, 0xdf, 0xf6, 0x3d,
	0xed, 0xfb, 0xbe, 0xa7, 0x7d, 0xb0, 0xd4, 0xff, 0x7c, 0xfb, 0x23, 0x00, 0x00, 0xff, 0xff, 0xa3,
	0x87, 0xef, 0xe1, 0xaf, 0x02, 0x00, 0x00,
}
